name: CI/CD Pipeline

on:
  pull_request:
    branches:
      - main
      - develop
  push:
    branches:
      - main
      - develop
  workflow_dispatch: # For manual prod deployment

env:
  REGISTRY: ghcr.io
  DEV_NAMESPACE: dev
  PROD_NAMESPACE: prod

jobs:
  # Step 1: Test
  test:
    name: 1Ô∏è‚É£ Run Tests
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: '**/package-lock.json'

      - name: Install dependencies
        working-directory: src
        run: npm ci

      - name: Run linter
        working-directory: src
        run: npm run lint || echo "‚ö†Ô∏è  Linter warnings (non-blocking)"

      - name: Type check
        working-directory: src
        run: npx tsc --noEmit || echo "‚ö†Ô∏è  Type check warnings (non-blocking)"

  # Step 2: Build Docker Image
  build:
    name: 2Ô∏è‚É£ Build Docker Image
    runs-on: ubuntu-latest
    needs: test
    if: (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && needs.test.result == 'success'
    permissions:
      contents: read
      packages: write
    outputs:
      image_tag: ${{ github.run_number }} # Output the run number as the image tag
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v5

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.CONTAINER_TOKEN }}

      - name: Set image repository (lowercase)
        id: image-repo
        run: |
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          echo "repo_owner=${REPO_OWNER}" >> $GITHUB_OUTPUT
          echo "repo_name=${REPO_NAME}" >> $GITHUB_OUTPUT

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ghcr.io/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}:${{ github.run_number }}
            ghcr.io/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}:latest
          platforms: linux/amd64
          cache-from: type=registry,ref=ghcr.io/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}:latest
          cache-to: type=inline
          build-args: |
            NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL }}
            NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=${{ secrets.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY }}

      - name: Output image info
        run: |
          echo "‚úÖ Image pushed:"
          echo "   ghcr.io/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}:${{ github.run_number }}"
          echo "   ghcr.io/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}:latest"

      - name: Verify image was pushed
        run: |
          IMAGE="ghcr.io/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}:${{ github.run_number }}"
          sleep 5
          docker pull ${IMAGE} || echo "‚ö†Ô∏è  Image verification skipped"

  # Step 3: Deploy to Dev (Automatic)
  deploy-dev:
    name: 3Ô∏è‚É£ Deploy to Dev
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' && needs.build.result == 'success'
    environment: dev
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3

      - name: Set up Helm
        uses: azure/setup-helm@v3

      - name: Set image repository (lowercase)
        id: image-repo
        run: |
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          echo "repo_owner=${REPO_OWNER}" >> $GITHUB_OUTPUT
          echo "repo_name=${REPO_NAME}" >> $GITHUB_OUTPUT

      - name: Set up SSH tunnel to Kubernetes API
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
          ssh-passphrase: ${{ secrets.SSH_PASSPHRASE }}

      - name: Configure kubectl via SSH tunnel
        run: |
          # Decode kubeconfig
          echo "${{ secrets.DEV_KUBECONFIG }}" | base64 -d > /tmp/kubeconfig
          
          # Extract server IP from kubeconfig
          SERVER_IP=$(grep -oP 'server:\s*\Khttps://[^:]+' /tmp/kubeconfig | sed 's|https://||' || echo "72.62.40.154")
          echo "Kubernetes server IP: ${SERVER_IP}"
          
          # Update kubeconfig with external IP
          sed -i "s|server: https://.*:6443|server: https://${SERVER_IP}:6443|g" /tmp/kubeconfig
          
          # Set up SSH tunnel
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -f -N -L 6443:${SERVER_IP}:6443 root@${SERVER_IP}
          sleep 2
          
          # Update kubeconfig to use localhost tunnel
          sed -i "s|server: https://${SERVER_IP}:6443|server: https://127.0.0.1:6443|g" /tmp/kubeconfig
          
          export KUBECONFIG=/tmp/kubeconfig
          kubectl cluster-info

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.CONTAINER_TOKEN }}

      - name: Configure image pull secrets for GHCR
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          kubectl create secret docker-registry ghcr-secret \
            --docker-server=ghcr.io \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.CONTAINER_TOKEN }} \
            --namespace ${DEV_NAMESPACE} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy frontend to dev
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          IMAGE_TAG="${{ needs.build.outputs.image_tag }}"
          if [ -z "$IMAGE_TAG" ]; then
            echo "‚ö†Ô∏è  Image tag from build job not found, falling back to github.run_number"
            IMAGE_TAG="${{ github.run_number }}"
          fi
          echo "üöÄ Deploying to DEV with tag: ${IMAGE_TAG}"
          
          # Check for stuck Helm releases
          echo "Checking for stuck Helm releases..."
          RELEASE_STATUS=$(helm status frontend -n ${DEV_NAMESPACE} 2>&1 || echo "not-found")
          
          if echo "$RELEASE_STATUS" | grep -qE "(pending-install|pending-upgrade|pending-rollback)"; then
            echo "‚ö†Ô∏è  Found stuck Helm release, attempting cleanup..."
            helm rollback frontend -n ${DEV_NAMESPACE} || true
            sleep 2
            helm delete frontend -n ${DEV_NAMESPACE} || true
            sleep 2
          fi
          
          # Deploy new version
          echo "üöÄ Deploying new version..."
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            DEPLOY_OUTPUT=$(helm upgrade --install frontend ./charts \
              --namespace ${DEV_NAMESPACE} \
              --create-namespace \
              -f env-values/dev/global.yaml \
              -f env-values/dev/frontend.yaml \
              --set image.tag=${IMAGE_TAG} \
              --set image.repository=${REGISTRY}/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }} \
              --set imagePullSecrets[0].name=ghcr-secret \
              --wait --timeout=5m 2>&1)
            
            DEPLOY_EXIT_CODE=$?
            
            if [ $DEPLOY_EXIT_CODE -eq 0 ]; then
              echo "‚úÖ Deployment successful!"
              echo "$DEPLOY_OUTPUT"
              break
            elif echo "$DEPLOY_OUTPUT" | grep -q "another operation (install/upgrade/rollback) is in progress"; then
              echo "‚ö†Ô∏è  Helm upgrade failed, checking for stuck release..."
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Attempting cleanup and retry ($RETRY_COUNT/$MAX_RETRIES)..."
                helm rollback frontend -n ${DEV_NAMESPACE} || true
                sleep 3
                helm delete frontend -n ${DEV_NAMESPACE} || true
                sleep 3
              else
                echo "‚ùå Deployment failed after $MAX_RETRIES retries"
                exit 1
              fi
            else
              echo "‚ùå Deployment failed with error:"
              echo "$DEPLOY_OUTPUT"
              exit 1
            fi
          done

      - name: Verify deployment
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          echo "üìä Deployment status:"
          kubectl get pods -n ${DEV_NAMESPACE} -l app.kubernetes.io/name=frontend
          echo ""
          echo "üìä Service status:"
          kubectl get svc -n ${DEV_NAMESPACE} -l app.kubernetes.io/name=frontend

  # Step 4: Deploy to Prod (Requires Approval)
  deploy-prod:
    name: 4Ô∏è‚É£ Deploy to Prod (Requires Approval)
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'workflow_dispatch'
    environment: 
      name: production
      # Add required reviewers in GitHub repository settings ‚Üí Environments ‚Üí production
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3

      - name: Set up Helm
        uses: azure/setup-helm@v3

      - name: Set image repository (lowercase)
        id: image-repo
        run: |
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          echo "repo_owner=${REPO_OWNER}" >> $GITHUB_OUTPUT
          echo "repo_name=${REPO_NAME}" >> $GITHUB_OUTPUT

      - name: Set up SSH tunnel to Kubernetes API
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
          ssh-passphrase: ${{ secrets.SSH_PASSPHRASE }}

      - name: Configure kubectl via SSH tunnel
        run: |
          # Decode kubeconfig
          echo "${{ secrets.PROD_KUBECONFIG }}" | base64 -d > /tmp/kubeconfig
          
          # Extract server IP from kubeconfig
          SERVER_IP=$(grep -oP 'server:\s*\Khttps://[^:]+' /tmp/kubeconfig | sed 's|https://||' || echo "72.62.40.154")
          echo "Kubernetes server IP: ${SERVER_IP}"
          
          # Update kubeconfig with external IP
          sed -i "s|server: https://.*:6443|server: https://${SERVER_IP}:6443|g" /tmp/kubeconfig
          
          # Set up SSH tunnel
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -f -N -L 6443:${SERVER_IP}:6443 root@${SERVER_IP}
          sleep 2
          
          # Update kubeconfig to use localhost tunnel
          sed -i "s|server: https://${SERVER_IP}:6443|server: https://127.0.0.1:6443|g" /tmp/kubeconfig
          
          export KUBECONFIG=/tmp/kubeconfig
          kubectl cluster-info

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.CONTAINER_TOKEN }}

      - name: Configure image pull secrets for GHCR
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          kubectl create secret docker-registry ghcr-secret \
            --docker-server=ghcr.io \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.CONTAINER_TOKEN }} \
            --namespace ${PROD_NAMESPACE} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy frontend to prod
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          IMAGE_TAG="${{ needs.build.outputs.image_tag }}"
          if [ -z "$IMAGE_TAG" ]; then
            echo "‚ö†Ô∏è  Image tag from build job not found, falling back to github.run_number"
            IMAGE_TAG="${{ github.run_number }}"
          fi
          # Allow manual override for image_tag if workflow_dispatch input is provided
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            IMAGE_TAG="${{ github.event.inputs.image_tag }}"
          fi
          echo "üöÄ Deploying to PRODUCTION with tag: ${IMAGE_TAG}"
          
          helm upgrade --install frontend ./charts \
            --namespace ${PROD_NAMESPACE} \
            --create-namespace \
            -f env-values/prod/global.yaml \
            -f env-values/prod/frontend.yaml \
            --set image.tag=${IMAGE_TAG} \
            --set image.repository=${REGISTRY}/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }} \
            --set imagePullSecrets[0].name=ghcr-secret \
            --wait --timeout=5m

      - name: Verify deployment
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          echo "üìä Deployment status:"
          kubectl get pods -n ${PROD_NAMESPACE} -l app.kubernetes.io/name=frontend
          echo ""
          echo "üìä Service status:"
          kubectl get svc -n ${PROD_NAMESPACE} -l app.kubernetes.io/name=frontend
