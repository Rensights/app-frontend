name: CI/CD Pipeline

on:
  pull_request:
    branches:
      - main
      - develop
  push:
    branches:
      - main
      - develop
  workflow_dispatch: # For manual prod deployment

env:
  REGISTRY: ghcr.io
  DEV_NAMESPACE: dev
  PROD_NAMESPACE: prod

jobs:
  # Step 1: Test
  test:
    name: 1Ô∏è‚É£ Run Tests
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Check src directory structure
        run: |
          echo "Checking src directory..."
          if [ -d "src" ]; then
            echo "‚úÖ src directory exists"
            ls -la src/ | head -10
            if [ -f "src/package-lock.json" ]; then
              echo "‚úÖ package-lock.json found in src/"
            else
              echo "‚ö†Ô∏è  package-lock.json not found in src/"
            fi
          else
            echo "‚ùå src directory does not exist"
          fi

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Verify package-lock.json exists
        run: |
          if [ -f "src/package-lock.json" ]; then
            echo "‚úÖ Found src/package-lock.json"
            ls -lh src/package-lock.json
          else
            echo "‚ùå src/package-lock.json not found!"
            echo "Files in src/:"
            ls -la src/ | head -20
            exit 1
          fi

      - name: Get npm cache directory
        id: npm-cache
        shell: bash
        run: |
          echo "dir=$(npm config get cache)" >> $GITHUB_OUTPUT

      - name: Cache npm dependencies
        uses: actions/cache@v4
        with:
          path: ${{ steps.npm-cache.outputs.dir }}
          key: ${{ runner.os }}-node-${{ hashFiles('src/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install dependencies
        working-directory: src
        run: |
          echo "Current directory: $(pwd)"
          echo "Files in current directory:"
          ls -la | head -20
          echo ""
          echo "Checking for package-lock.json:"
          if [ -f "package-lock.json" ]; then
            echo "‚úÖ package-lock.json found"
            ls -lh package-lock.json
            npm ci
          else
            echo "‚ùå package-lock.json not found, generating it..."
            npm install
          fi

      - name: Run linter
        working-directory: src
        run: npm run lint || echo "‚ö†Ô∏è  Linter warnings (non-blocking)"

      - name: Type check
        working-directory: src
        run: npx tsc --noEmit || echo "‚ö†Ô∏è  Type check warnings (non-blocking)"

  # Step 2: Build Docker Image
  build:
    name: 2Ô∏è‚É£ Build Docker Image
    runs-on: ubuntu-latest
    needs: test
    if: (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && needs.test.result == 'success'
    permissions:
      contents: read
      packages: write
    outputs:
      image_tag: ${{ github.run_number }} # Output the run number as the image tag
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.CONTAINER_TOKEN }}

      - name: Set image repository (lowercase)
        id: image-repo
        run: |
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          echo "repo_owner=${REPO_OWNER}" >> $GITHUB_OUTPUT
          echo "repo_name=${REPO_NAME}" >> $GITHUB_OUTPUT

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ghcr.io/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}:${{ github.run_number }}
            ghcr.io/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}:latest
          platforms: linux/amd64
          cache-from: type=registry,ref=ghcr.io/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}:latest
          cache-to: type=inline
          build-args: |
            NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL }}
            NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=${{ secrets.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY }}

      - name: Output image info
        run: |
          echo "‚úÖ Image pushed:"
          echo "   ghcr.io/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}:${{ github.run_number }}"
          echo "   ghcr.io/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}:latest"

      - name: Verify image was pushed
        run: |
          IMAGE="ghcr.io/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}:${{ github.run_number }}"
          sleep 5
          docker pull ${IMAGE} || echo "‚ö†Ô∏è  Image verification skipped"

  # Step 3: Deploy to Dev (Automatic)
  deploy-dev:
    name: 3Ô∏è‚É£ Deploy to Dev
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' && needs.build.result == 'success'
    environment: dev
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3

      - name: Set up Helm
        uses: azure/setup-helm@v3

      - name: Set image repository (lowercase)
        id: image-repo
        run: |
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          echo "repo_owner=${REPO_OWNER}" >> $GITHUB_OUTPUT
          echo "repo_name=${REPO_NAME}" >> $GITHUB_OUTPUT

      - name: Set up SSH with Passphrase
        run: |
          # Start ssh-agent
          eval "$(ssh-agent -s)"
          echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> $GITHUB_ENV
          echo "SSH_AGENT_PID=$SSH_AGENT_PID" >> $GITHUB_ENV
          
          # Write private key to file (use absolute path)
          SSH_KEY_PATH="$HOME/.ssh/id_ed25519"
          mkdir -p "$HOME/.ssh"
          printf '%s\n' "${{ secrets.SSH_PRIVATE_KEY }}" > "$SSH_KEY_PATH"
          chmod 600 "$SSH_KEY_PATH"
          
          # Verify file was created
          if [ ! -f "$SSH_KEY_PATH" ]; then
            echo "‚ùå Error: SSH key file was not created at $SSH_KEY_PATH"
            exit 1
          fi
          echo "‚úÖ SSH key file created: $(ls -lh "$SSH_KEY_PATH")"
          
          # Install expect if not available
          sudo apt-get update -qq && sudo apt-get install -y -qq expect || true
          
          # Create expect script to handle passphrase (use absolute path)
          cat > /tmp/ssh-add.exp << 'EXPECT_SCRIPT'
          #!/usr/bin/expect -f
          set timeout 30
          set key_path "$env(HOME)/.ssh/id_ed25519"
          puts "Attempting to add key from: $key_path"
          
          if {![file exists $key_path]} {
            puts "ERROR: Key file does not exist at $key_path"
            exit 1
          }
          
          spawn ssh-add "$key_path"
          expect {
            "Enter passphrase" {
              puts "Passphrase prompt detected, sending passphrase..."
              send "$env(SSH_PASSPHRASE)\r"
              exp_continue
            }
            "Identity added" {
              puts "‚úÖ Identity added successfully"
              expect eof
            }
            "Bad passphrase" {
              puts "‚ùå ERROR: Bad passphrase"
              exit 1
            }
            "Permission denied" {
              puts "‚ùå ERROR: Permission denied"
              exit 1
            }
            timeout {
              puts "‚ùå ERROR: Timeout waiting for response"
              exit 1
            }
            eof {
              puts "Process ended"
            }
          }
          catch wait result
          set exit_code [lindex $result 3]
          if {$exit_code != 0} {
            puts "‚ùå ssh-add exited with code: $exit_code"
            exit $exit_code
          }
          EXPECT_SCRIPT
          
          chmod +x /tmp/ssh-add.exp
          
          # Add key with passphrase (export variables for expect)
          export SSH_PASSPHRASE="${{ secrets.SSH_PASSPHRASE }}"
          export HOME="$HOME"
          echo "HOME=$HOME" >> $GITHUB_ENV
          
          # Run expect script with output
          echo "Running expect script..."
          /tmp/ssh-add.exp || {
            echo "‚ùå Expect script failed with exit code: $?"
            exit 1
          }
          
          # Verify key was added
          ssh-add -l
          
          # Test connection
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@72.62.40.154 "echo 'SSH connection successful'"

      - name: Configure kubectl via SSH tunnel
        run: |
          # Decode kubeconfig
          echo "${{ secrets.DEV_KUBECONFIG }}" | base64 -d > /tmp/kubeconfig
          
          # Use external server IP for SSH connection (always use the actual server IP)
          SSH_SERVER_IP="72.62.40.154"
          
          # Extract Kubernetes API server from kubeconfig (might be localhost or internal IP)
          K8S_SERVER=$(grep -oP 'server:\s*\Khttps://[^:]+' /tmp/kubeconfig | sed 's|https://||' || echo "127.0.0.1")
          echo "Kubernetes API server from kubeconfig: ${K8S_SERVER}"
          echo "SSH server IP: ${SSH_SERVER_IP}"
          
          # Set up SSH tunnel: tunnel local port 6443 to K8S server on remote
          # If K8S server is localhost/127.0.0.1, tunnel to 127.0.0.1:6443 on remote
          # Otherwise tunnel to the K8S server IP
          if [ "${K8S_SERVER}" = "127.0.0.1" ] || [ "${K8S_SERVER}" = "localhost" ]; then
            REMOTE_K8S="127.0.0.1:6443"
          else
            REMOTE_K8S="${K8S_SERVER}:6443"
          fi
          
          echo "Setting up SSH tunnel: localhost:6443 -> ${SSH_SERVER_IP}:${REMOTE_K8S}"
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -f -N -L 6443:${REMOTE_K8S} root@${SSH_SERVER_IP}
          sleep 2
          
          # Update kubeconfig to use localhost tunnel
          sed -i "s|server: https://.*:6443|server: https://127.0.0.1:6443|g" /tmp/kubeconfig
          
          export KUBECONFIG=/tmp/kubeconfig
          kubectl cluster-info

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.CONTAINER_TOKEN }}

      - name: Configure image pull secrets for GHCR
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          kubectl create secret docker-registry ghcr-secret \
            --docker-server=ghcr.io \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.CONTAINER_TOKEN }} \
            --namespace ${DEV_NAMESPACE} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Setup frontend-config secret for dev
        id: frontend-config
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          echo "Setting up frontend-config secret with backend URL..."
          # Get backend URL from ingress or use default
          BACKEND_URL="http://dev-api.72.62.40.154.nip.io:31416"
          
          # Try to get from backend ingress if it exists
          if kubectl get ingress backend -n ${DEV_NAMESPACE} &>/dev/null; then
            BACKEND_HOST=$(kubectl get ingress backend -n ${DEV_NAMESPACE} -o jsonpath='{.spec.rules[0].host}' 2>/dev/null || echo "")
            if [ -n "$BACKEND_HOST" ]; then
              BACKEND_URL="http://${BACKEND_HOST}:31416"
              echo "Found backend host from ingress: $BACKEND_HOST"
            fi
          fi
          
          echo "Using backend URL: $BACKEND_URL"
          STRIPE_KEY="pk_test_51SMUlmCasMqex534KJuqfzLCrTVoMNlUcZAmEXFsGp1nWOTPsFVNDjf4FI6B02t9YLMDS87SPHqcxnPb6Xf53CyI00kXxX7B1l"
          
          # Store values for use in Helm deployment
          echo "api_url=${BACKEND_URL}" >> $GITHUB_OUTPUT
          echo "stripe_key=${STRIPE_KEY}" >> $GITHUB_OUTPUT
          
          # Also create/update the secret as fallback
          kubectl create secret generic frontend-config \
            --from-literal=NEXT_PUBLIC_API_URL="$BACKEND_URL" \
            --from-literal=NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY="$STRIPE_KEY" \
            --namespace ${DEV_NAMESPACE} \
            --dry-run=client -o yaml | kubectl apply -f -
          echo "‚úÖ Frontend config secret updated"

      - name: Deploy frontend to dev
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          IMAGE_TAG="${{ needs.build.outputs.image_tag }}"
          if [ -z "$IMAGE_TAG" ]; then
            echo "‚ö†Ô∏è  Image tag from build job not found, falling back to github.run_number"
            IMAGE_TAG="${{ github.run_number }}"
          fi
          echo "üöÄ Deploying to DEV with tag: ${IMAGE_TAG}"
          
          # Check for stuck Helm releases
          echo "Checking for stuck Helm releases..."
          RELEASE_STATUS=$(helm status frontend -n ${DEV_NAMESPACE} 2>&1 || echo "not-found")
          
          if echo "$RELEASE_STATUS" | grep -qE "(pending-install|pending-upgrade|pending-rollback)"; then
            echo "‚ö†Ô∏è  Found stuck Helm release, attempting cleanup..."
            helm rollback frontend -n ${DEV_NAMESPACE} || true
            sleep 2
            helm delete frontend -n ${DEV_NAMESPACE} || true
            sleep 2
          fi
          
          # Deploy new version
          echo "üöÄ Deploying new version..."
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Attempt $((RETRY_COUNT + 1))/$MAX_RETRIES..."
            
            # Check if global.yaml exists, if not skip it
            VALUES_FILES="-f env-values/dev/frontend.yaml"
            if [ -f "env-values/dev/global.yaml" ]; then
              VALUES_FILES="-f env-values/dev/global.yaml -f env-values/dev/frontend.yaml"
            fi
            
            DEPLOY_OUTPUT=$(helm upgrade --install frontend ./charts \
            --namespace ${DEV_NAMESPACE} \
            --create-namespace \
            ${VALUES_FILES} \
            --set image.tag=${IMAGE_TAG} \
            --set image.repository=${REGISTRY}/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }} \
            --set imagePullSecrets[0].name=ghcr-secret \
            --set extraEnv.API_URL="${{ steps.frontend-config.outputs.api_url }}" \
            --set extraEnv.NEXT_PUBLIC_API_URL="${{ steps.frontend-config.outputs.api_url }}" \
            --set extraEnv.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY="${{ steps.frontend-config.outputs.stripe_key }}" \
            --wait --timeout=5m 2>&1) || true
            
            DEPLOY_EXIT_CODE=${PIPESTATUS[0]}
            
            if [ $DEPLOY_EXIT_CODE -eq 0 ]; then
              echo "‚úÖ Deployment successful!"
              echo "$DEPLOY_OUTPUT"
              break
            elif echo "$DEPLOY_OUTPUT" | grep -q "another operation (install/upgrade/rollback) is in progress"; then
              echo "‚ö†Ô∏è  Helm upgrade failed, checking for stuck release..."
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Attempting cleanup and retry ($RETRY_COUNT/$MAX_RETRIES)..."
                helm rollback frontend -n ${DEV_NAMESPACE} || true
                sleep 3
                helm delete frontend -n ${DEV_NAMESPACE} || true
                sleep 3
              else
                echo "‚ùå Deployment failed after $MAX_RETRIES retries"
                echo "Last error output:"
                echo "$DEPLOY_OUTPUT"
                exit 1
              fi
            else
              echo "‚ùå Deployment failed with error:"
              echo "$DEPLOY_OUTPUT"
              
              # Show more debug info
              echo ""
              echo "Debug information:"
              echo "Namespace: ${DEV_NAMESPACE}"
              echo "Image tag: ${IMAGE_TAG}"
              echo "Image repo: ${REGISTRY}/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}"
              echo "Values files: ${VALUES_FILES}"
              echo ""
              echo "Checking Helm release status:"
              helm status frontend -n ${DEV_NAMESPACE} || echo "Release not found"
              
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -ge $MAX_RETRIES ]; then
                exit 1
              else
                echo "Retrying in 5 seconds..."
                sleep 5
              fi
            fi
          done

      - name: Verify deployment
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          echo "üìä Deployment status:"
          kubectl get pods -n ${DEV_NAMESPACE} -l app.kubernetes.io/name=frontend
          echo ""
          echo "üìä Service status:"
          kubectl get svc -n ${DEV_NAMESPACE} -l app.kubernetes.io/name=frontend

  # Step 4: Deploy to Prod (Requires Approval)
  deploy-prod:
    name: 4Ô∏è‚É£ Deploy to Prod (Requires Approval)
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'workflow_dispatch'
    environment: 
      name: production
      # Add required reviewers in GitHub repository settings ‚Üí Environments ‚Üí production
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3

      - name: Set up Helm
        uses: azure/setup-helm@v3

      - name: Set image repository (lowercase)
        id: image-repo
        run: |
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          echo "repo_owner=${REPO_OWNER}" >> $GITHUB_OUTPUT
          echo "repo_name=${REPO_NAME}" >> $GITHUB_OUTPUT

      - name: Set up SSH with Passphrase
        run: |
          # Start ssh-agent
          eval "$(ssh-agent -s)"
          echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> $GITHUB_ENV
          echo "SSH_AGENT_PID=$SSH_AGENT_PID" >> $GITHUB_ENV
          
          # Write private key to file (use absolute path)
          SSH_KEY_PATH="$HOME/.ssh/id_ed25519"
          mkdir -p "$HOME/.ssh"
          printf '%s\n' "${{ secrets.SSH_PRIVATE_KEY }}" > "$SSH_KEY_PATH"
          chmod 600 "$SSH_KEY_PATH"
          
          # Verify file was created
          if [ ! -f "$SSH_KEY_PATH" ]; then
            echo "‚ùå Error: SSH key file was not created at $SSH_KEY_PATH"
            exit 1
          fi
          echo "‚úÖ SSH key file created: $(ls -lh "$SSH_KEY_PATH")"
          
          # Install expect if not available
          sudo apt-get update -qq && sudo apt-get install -y -qq expect || true
          
          # Create expect script to handle passphrase (use absolute path)
          cat > /tmp/ssh-add.exp << 'EXPECT_SCRIPT'
          #!/usr/bin/expect -f
          set timeout 30
          set key_path "$env(HOME)/.ssh/id_ed25519"
          puts "Attempting to add key from: $key_path"
          
          if {![file exists $key_path]} {
            puts "ERROR: Key file does not exist at $key_path"
            exit 1
          }
          
          spawn ssh-add "$key_path"
          expect {
            "Enter passphrase" {
              puts "Passphrase prompt detected, sending passphrase..."
              send "$env(SSH_PASSPHRASE)\r"
              exp_continue
            }
            "Identity added" {
              puts "‚úÖ Identity added successfully"
              expect eof
            }
            "Bad passphrase" {
              puts "‚ùå ERROR: Bad passphrase"
              exit 1
            }
            "Permission denied" {
              puts "‚ùå ERROR: Permission denied"
              exit 1
            }
            timeout {
              puts "‚ùå ERROR: Timeout waiting for response"
              exit 1
            }
            eof {
              puts "Process ended"
            }
          }
          catch wait result
          set exit_code [lindex $result 3]
          if {$exit_code != 0} {
            puts "‚ùå ssh-add exited with code: $exit_code"
            exit $exit_code
          }
          EXPECT_SCRIPT
          
          chmod +x /tmp/ssh-add.exp
          
          # Add key with passphrase (export variables for expect)
          export SSH_PASSPHRASE="${{ secrets.SSH_PASSPHRASE }}"
          export HOME="$HOME"
          echo "HOME=$HOME" >> $GITHUB_ENV
          
          # Run expect script with output
          echo "Running expect script..."
          /tmp/ssh-add.exp || {
            echo "‚ùå Expect script failed with exit code: $?"
            exit 1
          }
          
          # Verify key was added
          ssh-add -l
          
          # Test connection
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@72.62.40.154 "echo 'SSH connection successful'"

      - name: Configure kubectl via SSH tunnel
        run: |
          # Decode kubeconfig
          echo "${{ secrets.PROD_KUBECONFIG }}" | base64 -d > /tmp/kubeconfig
          
          # Use external server IP for SSH connection (always use the actual server IP)
          SSH_SERVER_IP="72.62.40.154"
          
          # Extract Kubernetes API server from kubeconfig (might be localhost or internal IP)
          K8S_SERVER=$(grep -oP 'server:\s*\Khttps://[^:]+' /tmp/kubeconfig | sed 's|https://||' || echo "127.0.0.1")
          echo "Kubernetes API server from kubeconfig: ${K8S_SERVER}"
          echo "SSH server IP: ${SSH_SERVER_IP}"
          
          # Set up SSH tunnel: tunnel local port 6443 to K8S server on remote
          # If K8S server is localhost/127.0.0.1, tunnel to 127.0.0.1:6443 on remote
          # Otherwise tunnel to the K8S server IP
          if [ "${K8S_SERVER}" = "127.0.0.1" ] || [ "${K8S_SERVER}" = "localhost" ]; then
            REMOTE_K8S="127.0.0.1:6443"
          else
            REMOTE_K8S="${K8S_SERVER}:6443"
          fi
          
          echo "Setting up SSH tunnel: localhost:6443 -> ${SSH_SERVER_IP}:${REMOTE_K8S}"
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -f -N -L 6443:${REMOTE_K8S} root@${SSH_SERVER_IP}
          sleep 2
          
          # Update kubeconfig to use localhost tunnel
          sed -i "s|server: https://.*:6443|server: https://127.0.0.1:6443|g" /tmp/kubeconfig
          
          export KUBECONFIG=/tmp/kubeconfig
          kubectl cluster-info

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.CONTAINER_TOKEN }}

      - name: Configure image pull secrets for GHCR
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          kubectl create secret docker-registry ghcr-secret \
            --docker-server=ghcr.io \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.CONTAINER_TOKEN }} \
            --namespace ${PROD_NAMESPACE} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Setup frontend-config secret for prod
        id: frontend-config-prod
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          echo "Setting up frontend-config secret with backend URL..."
          # Get backend URL from ingress or use default
          BACKEND_URL="https://api.72.62.40.154.nip.io"
          
          # Try to get from backend ingress if it exists
          if kubectl get ingress backend -n ${PROD_NAMESPACE} &>/dev/null; then
            BACKEND_HOST=$(kubectl get ingress backend -n ${PROD_NAMESPACE} -o jsonpath='{.spec.rules[0].host}' 2>/dev/null || echo "")
            if [ -n "$BACKEND_HOST" ]; then
              BACKEND_URL="https://${BACKEND_HOST}"
              echo "Found backend host from ingress: $BACKEND_HOST"
            fi
          fi
          
          echo "Using backend URL: $BACKEND_URL"
          STRIPE_KEY="pk_live_YOUR_LIVE_KEY"
          
          # Store values for use in Helm deployment
          echo "api_url=${BACKEND_URL}" >> $GITHUB_OUTPUT
          echo "stripe_key=${STRIPE_KEY}" >> $GITHUB_OUTPUT
          
          # Also create/update the secret as fallback
          kubectl create secret generic frontend-config \
            --from-literal=NEXT_PUBLIC_API_URL="$BACKEND_URL" \
            --from-literal=NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY="$STRIPE_KEY" \
            --namespace ${PROD_NAMESPACE} \
            --dry-run=client -o yaml | kubectl apply -f -
          echo "‚úÖ Frontend config secret updated"

      - name: Deploy frontend to prod
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          IMAGE_TAG="${{ needs.build.outputs.image_tag }}"
          if [ -z "$IMAGE_TAG" ]; then
            echo "‚ö†Ô∏è  Image tag from build job not found, falling back to github.run_number"
            IMAGE_TAG="${{ github.run_number }}"
          fi
          # Allow manual override for image_tag if workflow_dispatch input is provided
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            IMAGE_TAG="${{ github.event.inputs.image_tag }}"
          fi
          echo "üöÄ Deploying to PRODUCTION with tag: ${IMAGE_TAG}"
          
          helm upgrade --install frontend ./charts \
            --namespace ${PROD_NAMESPACE} \
            --create-namespace \
            -f env-values/prod/global.yaml \
            -f env-values/prod/frontend.yaml \
            --set image.tag=${IMAGE_TAG} \
            --set image.repository=${REGISTRY}/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }} \
            --set imagePullSecrets[0].name=ghcr-secret \
            --set extraEnv.API_URL="${{ steps.frontend-config-prod.outputs.api_url }}" \
            --set extraEnv.NEXT_PUBLIC_API_URL="${{ steps.frontend-config-prod.outputs.api_url }}" \
            --set extraEnv.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY="${{ steps.frontend-config-prod.outputs.stripe_key }}" \
            --wait --timeout=5m

      - name: Verify deployment
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          echo "üìä Deployment status:"
          kubectl get pods -n ${PROD_NAMESPACE} -l app.kubernetes.io/name=frontend
          echo ""
          echo "üìä Service status:"
          kubectl get svc -n ${PROD_NAMESPACE} -l app.kubernetes.io/name=frontend
