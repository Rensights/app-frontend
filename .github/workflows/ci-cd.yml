name: CI/CD Pipeline

on:
  pull_request:
    branches:
      - main
      - develop
  push:
    branches:
      - main
      - develop
  workflow_dispatch: # For manual prod deployment

env:
  REGISTRY: ghcr.io
  DEV_NAMESPACE: dev
  PROD_NAMESPACE: prod

jobs:
  # Step 1: Test
  test:
    name: 1️⃣ Run Tests
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          submodules: recursive
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: src/package-lock.json

      - name: Install dependencies
        working-directory: src
        run: npm ci --prefer-offline --no-audit

      - name: Run linter
        working-directory: src
        run: npm run lint || echo "⚠️  Linter warnings (non-blocking)"

      - name: Type check
        working-directory: src
        run: npx tsc --noEmit || echo "⚠️  Type check warnings (non-blocking)"

  # Step 2: Build Docker Image
  build:
    name: 2️⃣ Build Docker Image
    runs-on: ubuntu-latest
    needs: test
    if: (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && needs.test.result == 'success'
    timeout-minutes: 20
    permissions:
      contents: read
      packages: write
    outputs:
      image_tag: ${{ github.run_number }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:latest
            network=host

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.CONTAINER_TOKEN }}

      - name: Set image repository (lowercase)
        id: image-repo
        run: |
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          echo "repo_owner=${REPO_OWNER}" >> $GITHUB_OUTPUT
          echo "repo_name=${REPO_NAME}" >> $GITHUB_OUTPUT

      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}
          tags: |
            type=raw,value=${{ github.run_number }}
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64
          cache-from: |
            type=gha
            type=registry,ref=ghcr.io/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}:buildcache
          cache-to: |
            type=gha,mode=max
            type=registry,ref=ghcr.io/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}:buildcache,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1
            NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL }}
            NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=${{ secrets.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY }}

      - name: Output image info
        run: |
          echo "✅ Image pushed:"
          echo "${{ steps.meta.outputs.tags }}" | sed 's/^/   /'

  # Step 3: Deploy to Dev (Automatic)
  deploy-dev:
    name: 3️⃣ Deploy to Dev
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' && needs.build.result == 'success'
    timeout-minutes: 15
    environment: dev
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Set image repository (lowercase)
        id: image-repo
        run: |
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          echo "repo_owner=${REPO_OWNER}" >> $GITHUB_OUTPUT
          echo "repo_name=${REPO_NAME}" >> $GITHUB_OUTPUT

      - name: Set up SSH with Passphrase
        run: |
          eval "$(ssh-agent -s)"
          echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> $GITHUB_ENV
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          SSH_KEY_PATH="$HOME/.ssh/id_ed25519"
          printf '%s\n' "${{ secrets.SSH_PRIVATE_KEY }}" > "$SSH_KEY_PATH"
          chmod 600 "$SSH_KEY_PATH"
          sudo apt-get update -qq && sudo apt-get install -y -qq expect || true
          cat > /tmp/ssh-add.exp << 'EXPECT_SCRIPT'
          #!/usr/bin/expect -f
          set timeout 30
          spawn ssh-add "$env(HOME)/.ssh/id_ed25519"
          expect {
            "Enter passphrase" { send "$env(SSH_PASSPHRASE)\r"; exp_continue }
            "Identity added" { expect eof }
            timeout { exit 1 }
          }
          EXPECT_SCRIPT
          chmod +x /tmp/ssh-add.exp
          export SSH_PASSPHRASE="${{ secrets.SSH_PASSPHRASE }}"
          /tmp/ssh-add.exp
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@72.62.40.154 "echo 'SSH connection successful'" || exit 1

      - name: Configure kubectl via SSH tunnel
        run: |
          echo "${{ secrets.DEV_KUBECONFIG }}" | base64 -d > /tmp/kubeconfig
          SSH_SERVER_IP="72.62.40.154"
          K8S_SERVER=$(grep -oP 'server:\s*\Khttps://[^:]+' /tmp/kubeconfig | sed 's|https://||' || echo "127.0.0.1")
          REMOTE_K8S="$([ "${K8S_SERVER}" = "127.0.0.1" ] || [ "${K8S_SERVER}" = "localhost" ] && echo "127.0.0.1:6443" || echo "${K8S_SERVER}:6443")"
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -f -N -L 6443:${REMOTE_K8S} root@${SSH_SERVER_IP}
          sleep 2
          sed -i "s|server: https://.*:6443|server: https://127.0.0.1:6443|g" /tmp/kubeconfig
          export KUBECONFIG=/tmp/kubeconfig
          kubectl cluster-info

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.CONTAINER_TOKEN }}

      - name: Configure image pull secrets for GHCR
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          kubectl create secret docker-registry ghcr-secret \
            --docker-server=ghcr.io \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.CONTAINER_TOKEN }} \
            --namespace ${DEV_NAMESPACE} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Setup frontend-config secret for dev
        id: frontend-config
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          BACKEND_URL="http://dev-api.72.62.40.154.nip.io:31416"
          if kubectl get ingress backend -n ${DEV_NAMESPACE} &>/dev/null; then
            BACKEND_HOST=$(kubectl get ingress backend -n ${DEV_NAMESPACE} -o jsonpath='{.spec.rules[0].host}' 2>/dev/null || echo "")
            [ -n "$BACKEND_HOST" ] && BACKEND_URL="http://${BACKEND_HOST}:31416"
          fi
          STRIPE_KEY="pk_test_51SMUlmCasMqex534KJuqfzLCrTVoMNlUcZAmEXFsGp1nWOTPsFVNDjf4FI6B02t9YLMDS87SPHqcxnPb6Xf53CyI00kXxX7B1l"
          echo "api_url=${BACKEND_URL}" >> $GITHUB_OUTPUT
          echo "stripe_key=${STRIPE_KEY}" >> $GITHUB_OUTPUT
          kubectl create secret generic frontend-config \
            --from-literal=NEXT_PUBLIC_API_URL="$BACKEND_URL" \
            --from-literal=NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY="$STRIPE_KEY" \
            --namespace ${DEV_NAMESPACE} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy frontend to dev
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          IMAGE_TAG="${{ needs.build.outputs.image_tag }}"
          API_URL="${{ steps.frontend-config.outputs.api_url }}"
          STRIPE_KEY="${{ steps.frontend-config.outputs.stripe_key }}"
          
          # Check for stuck Helm releases and clean up release secrets
          if helm list -n ${DEV_NAMESPACE} -q | grep -q "^frontend$"; then
            STATUS=$(helm status frontend -n ${DEV_NAMESPACE} -o json 2>/dev/null | jq -r '.info.status' 2>/dev/null || echo "unknown")
            if [[ "$STATUS" =~ ^(pending-install|pending-upgrade|pending-rollback|failed)$ ]]; then
              echo "⚠️  Cleaning up stuck release (status: $STATUS)..."
              # Delete stuck release secrets
              kubectl delete secret -n ${DEV_NAMESPACE} -l owner=helm,name=frontend 2>/dev/null || true
              helm uninstall frontend -n ${DEV_NAMESPACE} 2>&1 || true
              sleep 3
            fi
          fi
          
          # Clean up any orphaned release secrets
          kubectl get secrets -n ${DEV_NAMESPACE} -l owner=helm,name=frontend -o name 2>/dev/null | while read secret; do
            REVISION=$(echo "$secret" | grep -oP 'v\d+' | grep -oP '\d+' || echo "")
            if [ -n "$REVISION" ]; then
              # Check if this revision exists in helm history
              if ! helm history frontend -n ${DEV_NAMESPACE} 2>/dev/null | grep -q "$REVISION"; then
                echo "⚠️  Removing orphaned secret: $secret"
                kubectl delete "$secret" -n ${DEV_NAMESPACE} 2>/dev/null || true
              fi
            fi
          done
          
          VALUES_FILES="-f env-values/dev/frontend.yaml"
          [ -f "env-values/dev/global.yaml" ] && VALUES_FILES="-f env-values/dev/global.yaml -f env-values/dev/frontend.yaml"
          
          printf 'extraEnv:\n  API_URL: "%s"\n  NEXT_PUBLIC_API_URL: "%s"\n  NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY: "%s"\n' \
            "${API_URL}" "${API_URL}" "${STRIPE_KEY}" > /tmp/extra-env-values.yaml
          
          helm upgrade --install frontend ./charts \
            --namespace ${DEV_NAMESPACE} \
            --create-namespace \
            ${VALUES_FILES} \
            -f /tmp/extra-env-values.yaml \
            --set image.tag=${IMAGE_TAG} \
            --set image.repository=${REGISTRY}/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }} \
            --set imagePullSecrets[0].name=ghcr-secret \
            --rollback-on-failure --timeout=8m \
            --wait

      - name: Verify deployment
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          kubectl get pods -n ${DEV_NAMESPACE} -l app.kubernetes.io/name=frontend
          kubectl get svc -n ${DEV_NAMESPACE} -l app.kubernetes.io/name=frontend

  # Step 4: Deploy to Prod (Requires Approval)
  deploy-prod:
    name: 4️⃣ Deploy to Prod (Requires Approval)
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'workflow_dispatch'
    timeout-minutes: 15
    environment: 
      name: production
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Set image repository (lowercase)
        id: image-repo
        run: |
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          echo "repo_owner=${REPO_OWNER}" >> $GITHUB_OUTPUT
          echo "repo_name=${REPO_NAME}" >> $GITHUB_OUTPUT

      - name: Set up SSH with Passphrase
        run: |
          eval "$(ssh-agent -s)"
          echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> $GITHUB_ENV
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          SSH_KEY_PATH="$HOME/.ssh/id_ed25519"
          printf '%s\n' "${{ secrets.SSH_PRIVATE_KEY }}" > "$SSH_KEY_PATH"
          chmod 600 "$SSH_KEY_PATH"
          sudo apt-get update -qq && sudo apt-get install -y -qq expect || true
          cat > /tmp/ssh-add.exp << 'EXPECT_SCRIPT'
          #!/usr/bin/expect -f
          set timeout 30
          spawn ssh-add "$env(HOME)/.ssh/id_ed25519"
          expect {
            "Enter passphrase" { send "$env(SSH_PASSPHRASE)\r"; exp_continue }
            "Identity added" { expect eof }
            timeout { exit 1 }
          }
          EXPECT_SCRIPT
          chmod +x /tmp/ssh-add.exp
          export SSH_PASSPHRASE="${{ secrets.SSH_PASSPHRASE }}"
          /tmp/ssh-add.exp
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@72.62.40.154 "echo 'SSH connection successful'" || exit 1

      - name: Configure kubectl via SSH tunnel
        run: |
          echo "${{ secrets.PROD_KUBECONFIG }}" | base64 -d > /tmp/kubeconfig
          SSH_SERVER_IP="72.62.40.154"
          K8S_SERVER=$(grep -oP 'server:\s*\Khttps://[^:]+' /tmp/kubeconfig | sed 's|https://||' || echo "127.0.0.1")
          REMOTE_K8S="$([ "${K8S_SERVER}" = "127.0.0.1" ] || [ "${K8S_SERVER}" = "localhost" ] && echo "127.0.0.1:6443" || echo "${K8S_SERVER}:6443")"
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -f -N -L 6443:${REMOTE_K8S} root@${SSH_SERVER_IP}
          sleep 2
          sed -i "s|server: https://.*:6443|server: https://127.0.0.1:6443|g" /tmp/kubeconfig
          export KUBECONFIG=/tmp/kubeconfig
          kubectl cluster-info

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.CONTAINER_TOKEN }}

      - name: Configure image pull secrets for GHCR
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          kubectl create secret docker-registry ghcr-secret \
            --docker-server=ghcr.io \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.CONTAINER_TOKEN }} \
            --namespace ${PROD_NAMESPACE} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Setup frontend-config secret for prod
        id: frontend-config-prod
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          BACKEND_URL="https://api.72.62.40.154.nip.io"
          if kubectl get ingress backend -n ${PROD_NAMESPACE} &>/dev/null; then
            BACKEND_HOST=$(kubectl get ingress backend -n ${PROD_NAMESPACE} -o jsonpath='{.spec.rules[0].host}' 2>/dev/null || echo "")
            [ -n "$BACKEND_HOST" ] && BACKEND_URL="https://${BACKEND_HOST}"
          fi
          STRIPE_KEY="pk_live_YOUR_LIVE_KEY"
          echo "api_url=${BACKEND_URL}" >> $GITHUB_OUTPUT
          echo "stripe_key=${STRIPE_KEY}" >> $GITHUB_OUTPUT
          kubectl create secret generic frontend-config \
            --from-literal=NEXT_PUBLIC_API_URL="$BACKEND_URL" \
            --from-literal=NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY="$STRIPE_KEY" \
            --namespace ${PROD_NAMESPACE} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy frontend to prod
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          IMAGE_TAG="${{ needs.build.outputs.image_tag }}"
          [ -n "${{ github.event.inputs.image_tag }}" ] && IMAGE_TAG="${{ github.event.inputs.image_tag }}"
          API_URL="${{ steps.frontend-config-prod.outputs.api_url }}"
          STRIPE_KEY="${{ steps.frontend-config-prod.outputs.stripe_key }}"
          
          # Check for stuck Helm releases and clean up release secrets
          if helm list -n ${PROD_NAMESPACE} -q | grep -q "^frontend$"; then
            STATUS=$(helm status frontend -n ${PROD_NAMESPACE} -o json 2>/dev/null | jq -r '.info.status' 2>/dev/null || echo "unknown")
            if [[ "$STATUS" =~ ^(pending-install|pending-upgrade|pending-rollback|failed)$ ]]; then
              echo "⚠️  Cleaning up stuck release (status: $STATUS)..."
              # Delete stuck release secrets
              kubectl delete secret -n ${PROD_NAMESPACE} -l owner=helm,name=frontend 2>/dev/null || true
              helm uninstall frontend -n ${PROD_NAMESPACE} 2>&1 || true
              sleep 3
            fi
          fi
          
          printf 'extraEnv:\n  API_URL: "%s"\n  NEXT_PUBLIC_API_URL: "%s"\n  NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY: "%s"\n' \
            "${API_URL}" "${API_URL}" "${STRIPE_KEY}" > /tmp/extra-env-values-prod.yaml
          
          helm upgrade --install frontend ./charts \
            --namespace ${PROD_NAMESPACE} \
            --create-namespace \
            -f env-values/prod/global.yaml \
            -f env-values/prod/frontend.yaml \
            -f /tmp/extra-env-values-prod.yaml \
            --set image.tag=${IMAGE_TAG} \
            --set image.repository=${REGISTRY}/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }} \
            --set imagePullSecrets[0].name=ghcr-secret \
            --rollback-on-failure --timeout=8m \
            --wait

      - name: Verify deployment
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          kubectl get pods -n ${PROD_NAMESPACE} -l app.kubernetes.io/name=frontend
          kubectl get svc -n ${PROD_NAMESPACE} -l app.kubernetes.io/name=frontend
